datapath ='/scr/raps2/0_ES/deco/FT/'; % set datapath

%% Specify subjects, who you want to read in ==============================
subjects = {'01' '02' '03' '04' '05' '06' '07' '08' '09' '10' '11' '12' ...
            '13' '14' '15' '16' '17' '18' '19' '20' '21' '22' '23' '24' ...
            '25' '26' '27' '28' '29' '30' '31' '32' '33' '34' '35' '36' ...
            '37' '38'}; 
%subjects = {'01'}; 


%% Specify conditions of interest by their trigger ========================
PR = [61 62 63 64 65]';
UN = [161 162 163 164 165]';
UT = [121 122 123 124 125]';
UX = 98';
condition  = [PR UN UT num2cell(UX)];
conditions = {'PR' 'UN' 'UT' 'UX'};

all_conditions = [61 62 63 64 65 161 162 163 164 165 121 122 123 124 125 98]';

session  =[1 2];
sessions = {'S1' 'S2'};
colour   = ['A' 'B'];
colours  = {'A' 'B'};


nbtemp=75; % set to the max of trials which are possible per condition
for s=5:length(subjects);
    subj=subjects{s};
    sess=1;
    for col=1:2;% Specify 1=co vs 2=bw
        for c=1:2;%:size(conditions,2);
            infile_cond = [datapath 'TF/' 'redef/' subj sessions{sess} colours{col} conditions{c} '_cond.mat'];
            load (infile_cond, 'data_cond');
            
            trl=data_cond.sampleinfo;
            nbtrl = size(trl,1);
            
            
            if nbtrl<nbtemp
                nbtemp = nbtrl;
                break % resulting nbtemp will be used as min nb of trls permuted 
            end;
        end;
    end;
end;
         

nbperm = nbtemp; % = 49 minimum amount of trials
runperm = 1000; % number of permutations = 1000, here test by 100



%% Calculation of complex numbers plus extracts the phase angle ===========
%  Additionally a container structure is created for further use___________
for s=1;%:length(subjects);
    subj=subjects{s};
    sess=1; % S1
    for col=1;%:size(colour,2);
        for c=1:2; % 1 - PR, 2 - UN
            infile_cond = [datapath 'TF/' 'redef/' subj sessions{sess} colours{col} conditions{c} '_cond.mat'];
            load (infile_cond, 'data_cond');
            
            condtrl=data_cond.sampleinfo;
            nbcondtrl = size(condtrl,1);
            
            complexcfg = [];
            complexcfg.channel      = 'Cz';
            complexcfg.output       = 'fourier';
            complexcfg.method       = 'wavelet'; % other option: mtmconvol
            complexcfg.foi          = 4:2:12; % analysis from:step:to certain Frequency(Hz)
            complexcfg.width        = 3; % 4 cycles per time window ????
            complexcfg.toi          = -0.8:.01:0.15;
            
            data_complex  = ft_freqanalysis(complexcfg, data_cond);
            
            if c==1
                data_PRcommat = data_complex;
            else
                data_UNcommat = data_complex;
            end;
            
%% Calculates phase angle by looping over frequenciees ====================
            time = data_complex.time;
            curchan = data_complex.label; % get channel
            freqrg = data_complex.freq; % data_coh.cfg.foi gleicher inhalt
            
            itccond = nan(runperm,length(curchan),length(freqrg),size(data_complex.fourierspctrm,4));
            % It is useful to create the matrix before the loop, otherwise matlab tells you this warning about the fact that the matrix
            % changes size every loop iteration. So you create it before the loop, already with the good size. Makes the whole thing faster.
            
            disp(['Calculating ITC of condition ' num2str(conditions{c}) ' with permutations ' num2str(runperm)]);
            for curpermut = 1:runperm; % runs 1000 times
                current_permut = randperm(nbcondtrl,nbperm); % random pick of trials out of max trials available
                %here: minimum number of trials for all participants and conditions
                
                actualchan = 1:size(curchan);
                for curfreq = 1:size(freqrg,2)
                    
                    commat = squeeze(data_complex.fourierspctrm(:,actualchan,curfreq,:));
                    curangle = angle(commat(current_permut,:)); % calculates angle N=min trls
                    
                    for tpoint = 1:size(curangle,2) %calculate mean phase distribution
                        curveclength(tpoint) = circ_r(curangle(:,tpoint));
                        curvecdir(tpoint) = circ_mean(curangle(:,tpoint));
                        %curraysig(tpoint) = circ_rtest(curangle(:,tpoint));
                    end;
                    
                    itc(1,curfreq,:) = curveclength;
                    %vecdir(1,curfreq,:) = curvecdir;
                    %raysig(1,curfreq,:) = curraysig;
                    
                end;
                itccond(curpermut,:,:,:) = itc;
                %vecdircond(curpermut,:,:,:) = vecdir;
            end;
            ITC     = squeeze(nanmean(itccond,1)); % mean ignoring NANs
            %VECDIR  = squeeze(nanmean(vecdircond,1));
            
%% Creates a container structure ITCpr + ITCun ============================
            data_itccond = [];
            data_itccond.label = curchan;
            data_itccond.freq = freqrg;
            data_itccond.time = time;
            data_itccond.dimord = 'chan_freq_time';
            data_itccond.itc = itc; % permuted ITC per condition
            %data_itccond.vecdir = vecdir;
            %             data_itccond.raysig.pval = raysig;
            %             data_itccond.raysig.sig_uncorrected = raysig<0.05;
            %             data_itccond.raysig.sig_fdr = fdr_bh(raysig);
            
%% Save data_coh per subject ==============================================
            outfile_itccond = [datapath 'TF/' 'BI/' 'ITCcond/' subj sessions{sess} colours{col} conditions{c} '_itccond.mat'];
            save (outfile_itccond, 'data_itccond');
        end;
        
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Calculate ITCsum =======================================================
        nbPRtrl = size(data_PRcommat.fourierspctrm,1);
        nbUNtrl = size(data_UNcommat.fourierspctrm,1);
        
        itcsum = nan(runperm,length(curchan),length(freqrg),size(data_complex.fourierspctrm,4));
        % It is useful to create the matrix before the loop, otherwise matlab tells you this warning about the fact that the matrix
        % changes size every loop iteration. So you create it before the loop, already with the good size. Makes the whole thing faster.
        
        
        
        disp(['Calculating ITC of both conditions with permutations ' num2str(runperm)]);
        for curpermut = 1:runperm; % runs 1000 times
            current_permut = randperm(nbPRtrl+nbUNtrl,nbperm); % random pick of trials out of max trials available
            %here: minimum number of trials for all participants and conditions
            
            
            actualchan = 1:size(curchan);
            for curfreq = 1:size(freqrg,2)
                
                PRcommat = squeeze(data_PRcommat.fourierspctrm(:,actualchan,curfreq,:));
                UNcommat = squeeze(data_UNcommat.fourierspctrm(:,actualchan,curfreq,:));
                tempcommat = [PRcommat;UNcommat];
                curangle = angle(tempcommat(current_permut,:));
                
                for tpoint = 1:size(curangle,2) %calculate mean phase distribution
                    curveclength(tpoint) = circ_r(curangle(:,tpoint));
                    curvecdir(tpoint) = circ_mean(curangle(:,tpoint));
                    curraysig(tpoint) = circ_rtest(curangle(:,tpoint));
                end;
                
                itc(1,curfreq,:) = curveclength;
                %vecdir(1,curfreq,:) = curvecdir;
                %raysig(1,curfreq,:) = curraysig;
                
            end;
            itcsum(curpermut,:,:,:) = itc;
            %vecdirsum(curpermut,:,:,:) = vecdir;
            
        end;
        ITC     = squeeze(nanmean(itcsum,1)); % mean ignoring NANs
        %VECDIR  = squeeze(nanmean(vecdirsum,1));
        % put that in a structure per condition
        
%% Creates a container structure ITCpr + ITCun ============================
        data_itcsum = [];
        data_itcsum.label = curchan;
        data_itcsum.freq = freqrg;
        data_itcsum.time = time;
        data_itcsum.dimord = 'chan_freq_time';
        data_itcsum.itc = itc; % permuted ITCsum
        %data_itcsum.vecdir = vecdir;
        
%% Save data_coh per subject ==============================================
        outfile_itcsum = [datapath 'TF/' 'BI/' 'ITCcond/' subj sessions{sess} colours{col} '_itcsum.mat'];
        save (outfile_itcsum, 'data_itcsum');
    end;
end;


%% Calculate BI ===========================================================
for s=1;%:length(subjects);
    subj=subjects{s};
    sess=1;
    for col=1;% Specify 1=co vs 2=bw
        
        infile_itccond = [datapath 'TF/' 'BI/' 'ITCcond/' subj sessions{sess} colours{col} 'PR' '_itccond.mat'];
        load (infile_itccond, 'data_itccond');
        dataPR_itccond = data_itccond;
        infile_itccond = [datapath 'TF/' 'BI/' 'ITCcond/' subj sessions{sess} colours{col} 'UN' '_itccond.mat'];
        load (infile_itccond, 'data_itccond');
        dataUN_itccond = data_itccond;
        infile_itcsum = [datapath 'TF/' 'BI/' 'ITCcond/' subj sessions{sess} colours{col} '_itcsum.mat'];
        load (infile_itcsum, 'data_itcsum');
        
        BI = (dataPR_itccond.itc - data_itcsum.itc) .*  (dataUN_itccond.itc - data_itcsum.itc);
        
        %figure;
        %imagesc(squeeze(BI(1,:,:)));
        
%% Create new structure ===================================================
        
%% Save it
    end;
end;


%% Plot phase angle over all freqrg separate for co/bw per subject ========
for s=1;%:length(subjects);
    subj=subjects{s};
    sess=1;
    for col=1;% Specify 1=co vs 2=bw
        
        infile_itccond = [datapath 'TF/' 'BI/' 'ITCcond/' subj sessions{sess} colours{col} 'PR' '_itccond.mat'];
        load (infile_itccond, 'data_itccond');
        dataPR_itccond = data_itccond;
        infile_itccond = [datapath 'TF/' 'BI/' 'ITCcond/' subj sessions{sess} colours{col} 'UN' '_itccond.mat'];
        load (infile_itccond, 'data_itccond');
        dataUN_itccond = data_itccond;
    	infile_itcsum = [datapath 'TF/' 'BI/' 'ITCcond/' subj sessions{sess} colours{col} '_itcsum.mat'];
        load (infile_itcsum, 'data_itcsum');
        
        
% Plotting_________________________________________________________________
        figure;
        freqrg = data_itccond.freq;
        for curfreq = 1:size(freqrg,2)

            
            
            subplot(2,3,curfreq)
            plot(data_itccond.time,squeeze(dataPR_itccond.itc(1,curfreq,:)),'k'); 
            hold on
            plot(data_itccond.time,squeeze(dataUN_itccond.itc(1,curfreq,:)),'b');
            plot(data_itccond.time,squeeze(data_itcsum.itc(1,curfreq,:)),'r');
            plot(data_itccond.time,squeeze(BI(1,curfreq,:)),'--r'); 
            %plot(data_itccond.time,squeeze(BI(1,curfreq,:)),'--r');  % to enhence the effect visibly
            %plot(data_coh.time,(squeeze(dataPR_coh.raysig.sig_fdr(1,curfreq,:))),'--k');
            %plot(data_coh.time,(squeeze(dataUN_coh.raysig.sig_fdr(1,curfreq,:))),'--b');
            title([' freq : ' num2str(freqrg(curfreq)) ' Hz' ])
            hold off
            xlim([-0.8 0.15]);
            ylim([-1 1.1]); 
            
        end;
        legend('PR','UN','sum', 'BI');
    end;
end;




%%=======================================================================%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% END %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%